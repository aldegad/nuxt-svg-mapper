## Ray Casting Algorithm을 이용한 SVG 에디터

### 왜 SVG?

| 구분     | ✅ SVG                                                                                                                                              | Canvas                                                                                                                   |
| -------- | --------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| **장점** | - DOM 요소로 각 도형이 관리되어 구조가 명확함<br>- CSS, JS로 개별 스타일 및 이벤트 제어 용이<br>- 반응형/확대축소에 강함<br>- 디버깅 및 접근성 우수 | - 픽셀 단위로 빠른 렌더링<br>- 대량의 객체 처리에 유리                                                                   |
| **단점** | - 많은 객체가 있을 때 성능 저하<br>- 대용량 데이터 처리에 비효율적                                                                                  | - 도형이 DOM에 나타나지 않아 구조 파악 어려움<br>- ~~개별 객체에 직접 이벤트 할당 불가~~<br>- 상태 관리 및 디버깅 어려움 |

**SVG를 선택한 이유**

Canvas는 도형이 DOM에 존재하지 않기 때문에 구조 파악이 어렵고, 디버깅 및 스타일링이 불편합니다. 반면 SVG는 각 도형이 실제 DOM 요소로 존재하여, **개발 속도, 디버깅 효율성, 스타일 및 이벤트 처리**의 유연성 면에서 유리합니다. 이러한 이유로 **SVG 기반 에디터**를 설계하였습니다.

### 왜 Ray Casting?

웹 개발에서는 일반적으로 각 객체에 직접 이벤트를 바인딩하지만, **객체가 중첩된 경우 이벤트 충돌이나 예기치 못한 동작**이 발생할 수 있습니다.

이를 해결하기 위해 **Ray Casting Algorithm(point-in-polygon)**를 사용했습니다. 이는 마우스 좌표가 어떤 다각형 내부에 위치하는지 수학적으로 판정하는 기법으로, **중첩된 도형 상황에서도 일관된 선택 로직**을 제공합니다.

> prototype1에서는 두 방식을 혼합했으나, prototype2부터는 모든 이벤트를 Point-in-Polygon 방식으로 일원화했습니다.

### 마우스 이벤트 구조 설계

마우스 이벤트는 `useMouseEvents.ts`에서 추상화하고, 각 이벤트별로(`capturePointerEvents`, `captureDragEvents` 등) 파일을 분리, `index.ts`에서 조합하는 구조로 설계했습니다.

- **이벤트별 완전한 독립성**: 각 이벤트 로직을 별도 파일/함수로 분리하여, 내부 상태나 동작이 서로 영향을 주지 않도록 설계
- **사이드 이펙트 최소화**: 공통 상태는 상위에서 주입받아 사용, 예기치 않은 부작용 방지
- **유지보수 및 확장성**: 새로운 도구/이벤트 추가 시 기존 코드에 영향 없이 독립적으로 개발/테스트 가능
- **가독성 및 테스트 용이성**: 각 이벤트의 역할과 동작이 명확히 분리되어 디버깅/테스트가 쉬움

**관련 코드 경로**

- `src/composables/useCapture/useMouseEvents.ts`
- `src/composables/useCapture/useSetCoreEvents/`

#### useMouseEvents.ts의 목적

`useMouseEvents.ts`는 마우스 이벤트의 등록/해제 등 **기초적인 이벤트 관리 허브** 역할만 담당합니다. 실제 동작(포인터, 드래그 등)은 각 도구별로 독립적으로 구현되어, 이벤트 처리와 상태 관리를 추상화하여 재사용성을 높였습니다.

### 적용된 주요 알고리즘과 기법

이 SVG 에디터는 다양한 2D 기하 알고리즘과 상태 기반 인터랙션 로직을 활용하여 정밀한 도형 조작 기능을 제공합니다.

- **Point-in-Polygon Test (Ray Casting Algorithm)**
  - `src/utils/calc/isCaptured.ts`
  - 마우스 좌표가 다각형(폴리곤) 내부에 있는지 판정하기 위해 Ray Casting 기반의 Point-in-Polygon 알고리즘을 구현하였습니다.
  - 중첩된 도형 간의 선택 일관성을 유지할 수 있습니다.

- **거리 계산, Bounding Box, 엣지 감지 (Edge Detection)**
  - `src/utils/calc/calcDistance.ts`, `getAABBRect.ts`, `findEdgeCoord.ts`
  - 도형 간 거리, 크기, 경계 검출 등의 처리를 위해 유클리드 거리 계산, Axis-Aligned Bounding Box(AABB), 엣지 인식 등 기초 2D 기하 알고리즘을 사용합니다.

- **폴리곤 트리 구조 & 트리 평탄화/정렬**
  - `src/utils/polygon/makePolygonTree.ts`, `flattenPolygonTree.ts`, `reorderPolygons.ts`
  - 도형 간 그룹 및 계층 구조를 트리 형태로 관리하며, 선택/정렬을 위해 리스트로 평탄화하거나 재정렬하는 로직을 구현하였습니다.

- **상태 기반 인터랙션(State Machine) 및 기하 연산**
  - `src/composables/useCapture/useSetCoreEvents/` 하위 각 index.ts, `findCapturedItems.ts`, `captureTransformEvents/`
  - 마우스 이벤트 흐름을 상태머신으로 관리하며, 선택, 이동, 복제, 변형 등 인터랙션 처리에 벡터 연산과 최근접점 탐색(Nearest Neighbor Search) 등의 알고리즘을 활용하였습니다.

- **Sticky 이동 및 그룹 이동 로직**
  - `src/utils/polygon/moveStickyPolygons.ts`, `movePolygons.ts`
  - 여러 도형이 붙어 있는 경우, 이를 하나의 그룹처럼 함께 이동시킬 수 있도록 하는 Sticky 이동 로직을 구현하였습니다.

- **SVG 좌표 변환 및 사각형 포함 판정(Rectangle Containment Test)**
  - `src/utils/calc/calcSvgOffset.ts`, `isCapturedInRect.ts`
  - 마우스의 화면 좌표를 SVG 내부 좌표로 변환한 후, 특정 사각형 영역 안에 포함되는 도형을 판정하는 알고리즘을 적용하였습니다.

- **도형 정렬 및 분포 알고리즘 (Alignment & Distribution)**
  - `src/utils/polygon/alignPolygons.ts`
  - 여러 도형을 상단, 하단, 좌/우측, 중앙, 일정 간격 등으로 정렬하는 알고리즘 구현
  - 여러 도형을 상단/하단/좌우/중앙 정렬하거나 균등하게 분포시키는 기능을 구현하였습니다.
  - Bounding Box Alignment, Centroid Alignment, Even Distribution 등 그래픽 툴에서 쓰이는 2D 레이아웃 알고리즘을 참고하였습니다.
